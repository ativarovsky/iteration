---
title: "Writing Functions"
author: "Alice Tivarovsky"
date: "10/24/2019"
output: html_document
---
**NOTE: Not connected to github**

# Slides

If you're using the same code more than once, write a function. Prevents mistakes from contnuous copy and paste. 

Functions consist of 
- arguments(inputs)
- body (code that does stuff)
- Return objects (what the function produces)
 
 Scoping: this is how R looks for variables. Usually we're in the global environment. With functions, we crat a local environment. 
 
 
# Example 

## Setup 
```{r setup, include=FALSE}

library(tidyverse)
library(rvest)

knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
	fig.width = 8, 
  fig.height = 6,
  out.width = "90%"
)
options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)
scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
theme_set(theme_minimal() + theme(legend.position = "bottom"))

```

## Get Started 

The best way to build up a function is to start with code you’ve written outside a function. To see how this might work, I’ll start with a simple example: the chunk below takes a sample from a normal distribution and then computes the vector of Z scores for the sample.

```{r}
x = rnorm (n = 30, mean = 4, sd = 2.3)
# another vector: 
x_again = rnorm (n = 30, mean = 6, sd = .3)
y = rnorm(n = 30, mean = 24, sd = 2.3)

z_transformation = mean(x)/sd(x)
(x_again - mean(x_again)/sd(x_again))
```

To avoid the above, write a function: 

```{r}
# here, x is what we're calling whatever we put in the function and z_score is the name of the function. 

z_score = function(x) {
  z = (x - mean(x))/sd(x)
  z
}
```

Now we try out the function. 

```{r error = TRUE}
z_score(x)
z_score(x = x) # same thing as above 
z_score(x = y)

z_score(x = 3)
z_score(x = "my name is alice")
z_score(x = c(TRUE, TRUE, FALSE, TRUE))

```

We can now define when the function breaks, i.e. conditional execution. 

```{r}
z_score = function(x) {
  
  if(!is.numeric(x)) {
    stop("argument should be numeric")}
  else if (length(x) == 1) {
    stop("Z scores cannot be computed for length 1 vectors")
  }
  z = (x - mean(x))/sd(x)
  z
}
```

Running again: 
```{r error = TRUE}
z_score(x)

z_score(x = 3)
z_score(x = "my name is alice")
z_score(x = c(TRUE, TRUE, FALSE, TRUE))

```


## Multiple Outputs

Write a function that produces multiple outputs. This function gives us both the mean and the standard deviation.  

```{r}
mean_and_sd = function(input_x) {
  
  if(!is.numeric(input_x)) {
    stop("argument should be numeric")
    }
  else if (length(input_x) < 3) {
    stop("x should be larger than 3")
  }
  tibble(
    mean_x = mean(input_x),
    sd_x = sd(input_x)  
  )
}
```

Test the function: 

```{r}
mean_and_sd(input_x = y)
```

Note that above, when we used a tibble, we chould have also used a list. Lists are cool because they allow you to keep track of things that aren't numbers. 

In general, either of these will be fine; which one you choose will depend on what kind of values you want to return, and what you plan to do with the function itself. If you want to return the original sample along with the computed values, a list might make sense; if you plan to run your function a lot and study the results, having a data frame will make it easier to use other tools. We’ll see more of that in iteration and simulation.

## Multiple Inputs

Go through this again. 

```{r}
sim_data = tibble(
  x = rnorm(30, mean = 1, sd = 1),
  y = 2 + 3 * x + rnorm(30, 0, 1)
)

ls_fit = lm(y ~ x, data = sim_data)
  
beta0_hat = coef(ls_fit)[1]
beta1_hat = coef(ls_fit)[2]
```


Write a function that simulates regression: 

```{r}

sim_regression = function(n, beta0 = 2, beta1 = 3) {
  
sim_data = tibble(
    x = rnorm(n, mean = 1, sd = 1),
    y = beta0 + beta1 * x + rnorm(n, 0, 1)
  )
  
ls_fit = lm(y ~ x, data = sim_data)
  
tibble(
    beta0_hat = coef(ls_fit)[1],
    beta1_hat = coef(ls_fit)[2]
  )
  }

sim_regression(3000)
```


# Argument names and scoping 

```{r}

```

