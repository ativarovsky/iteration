---
title: "Iteration and Listcols"
author: "Alice Tivarovsky"
date: "10/31/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---


# Slides


### For loops 
Loops consist of an output object; a sequence to iterate over; the loop body; and (optionally) an input object. For loops are hard to work with but purr package makes for loops easier using map s.  

Basic structure: output = map(input, f)


### Lists
Lists hold everything. They give you a way to mix different data types (dbl vectors, string vectors, data frames, etc.). Dataframes are a special type of list - one that is formatted as a rectangle. 

You can even put lists inside of lists - these are called list columns. This makes data easier to work with (even though it's hard to understand in the beginning). 


# Examples 

Setup code: 
```{r setup, include=FALSE}
library(tidyverse)
library(rvest)

knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
  out.width = "90%"
)
options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)
scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
theme_set(theme_minimal() + theme(legend.position = "bottom"))
```

## Lists
We need a brief digression about lists before we do anything.

In R, vectors are limited to a single data class – all elements are characters, or all numeric, or all logical. Trying to join the following vectors will result in _coersion_, as would creating vectors of mixed types.

```{r}
l = list(vec_numeric = 5:8,
         mat         = matrix(1:8, 2, 4),
         vec_logical = c(TRUE, FALSE),
         summary     = summary(rnorm(1000)))
l
```

We can pull stuff out of the list: 

```{r}
l$vec_numeric

l$summary
# you can also use the index
l[[2]]

#you can take a mean, do whatever
mean(l$vec_numeric)

```

Lists seem bizarre but are really useful. Right now, we’ll use them to hold general inputs and outputs of iterative processes. Even more importantly, we’ll see that data frames are actually a very specific kind of list – one comprised of vectors of the same length – which is why they can store variables of different types.


## For Loops

For this example, I’m going to start with the pretty simple data frame defined below, and confirm that “under the hood” this is a list.
```{r}
df = list(
  a = rnorm(20, 3, 1),
  b = rnorm(20, 0, 5),
  c = rnorm(20, 10, .2),
  d = rnorm(20, -3, 1)
)

#pulling stuff out of the list
df$a
df[[2]]
```

In the writing functions class, we wrote a function that returns mean and standard deviation. Here it is again: 
```{r}
mean_and_sd = function(x) {
  
  if (!is.numeric(x)) {
    stop("Argument x should be numeric")
  } else if (length(x) == 1) {
    stop("Cannot be computed for length 1 vectors")
  }
  
  mean_x = mean(x)
  sd_x = sd(x)

  tibble(
    mean = mean_x, 
    sd = sd_x
  )
}
```

Now, say we want to apply the function to every element in the list. We could do something like this: 
```{r}
mean_and_sd(df[[1]])
mean_and_sd(df[[2]])
mean_and_sd(df[[3]])
mean_and_sd(df[[4]])

```
But now we’ve broken our “don’t repeat code more than twice” rule! Specifically, we’ve applied the same function / operation to the elements of a list sequentially. This is exactly the kind of code repetition for loops address. 

Below, I define an output list with the same number of entries as my target dataframe; a sequence to iterate over; and a for loop body that applies the mean_and_sd function for each sequence element and saves the result.
```{r}
output = vector("list", length = 4) #give you 4 blank slots

# now the for loop
for (i in 1:4) {
  
  output[[i]] = mean_and_sd(df[[i]])
  
}
output
```

This is already much cleaner than using four almost-identical lines of code, and will make life easier the larger our sequence gets.

In this example, I bypassed a common first step in writing loops because I already had the function I wanted to repeat. Frequently, however, I’ll start with repeated code segements, then abstract the underlying process into a function, and then wrap things up in a for loop.

## Map

A criticism of for loops is that there’s a lot of overhead – you have to define your output vector / list, there’s the for loop bookkeeping to do, etc – that distracts from the purpose of the code. In this case, we want to apply mean_and_sd to each column of df, but we have to scan inside the for loop to figure that out.

The map functions in purrr try to make the purpose of your code clear. Compare the loop above to the line below.

```{r}
output = map(df, mean_and_sd)
```

You can do the same thing for any function: 
```{r}
output = map(df, mean_and_sd)

output = map(df, median)

output = map(df, summary) #this is a special summary function we talked about before
```

This is a way to be more explicit about your output: 
```{r}
output = map(df, ~mean_and_sd, .x)
```



## Revisiting Napoleon Dynamite

In reading data from the web and elsewhere, we wrote code that allowed us to scrape information in Amazon reviews; in writing functions we wrapped that code into a function called read_page_reviews which, for a given url, produces a data frame containing review titles, star ratings, and text.

```{r}
read_page_reviews = function(url) {
  
  h = read_html(url)
  
  title = h %>%
    html_nodes("#cm_cr-review_list .review-title") %>%
    html_text()
  
  stars = h %>%
    html_nodes("#cm_cr-review_list .review-rating") %>%
    html_text() %>%
    str_extract("\\d") %>%
    as.numeric()
  
  text = h %>%
    html_nodes(".review-data:nth-child(5)") %>%
    html_text()
  
  data_frame(title, stars, text)
}
```


We will now create a vector of urls that we want to operate on. 
```{r}
url_base = "https://www.amazon.com/product-reviews/B00005JNBQ/ref=cm_cr_arp_d_viewopt_rvwer?ie=UTF8&reviewerType=avp_only_reviews&sortBy=recent&pageNumber="
vec_urls = str_c(url_base, 1:5) #the str_c from the stringr package puts a number at the end of the string

vec_urls
```

Now, we'll write a for loop and map statement to pull out the first five pages of reviews. 

```{r}
url_base = "https://www.amazon.com/product-reviews/B00005JNBQ/ref=cm_cr_arp_d_viewopt_rvwer?ie=UTF8&reviewerType=avp_only_reviews&sortBy=recent&pageNumber="
vec_urls = str_c(url_base, 1:5) 

output = vector("list", length = 5)

for (i in 1:5) {
  
  output[[i]] = read_page_reviews(vec_urls[[i]])
  
}

# Alternatively, you could just use a map statement

output = map(vec_urls, read_page_reviews)
```

## List Columns 

Shifting gears a bit, let’s revisit the weather data from visualization and elsewhere; these data consist of one year of observations from three monitoring stations. The code below pulls these data into R (using the rnoaa package, which interacts with the NOAA API).

So again, we make a dataframe called weather and assign appropriate names. 

```{r}
weather = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728", "USC00519397", "USS0023B17S"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2016-01-01",
    date_max = "2016-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY", 
                      USC00519397 = "Waikiki_HA",
                      USS0023B17S = "Waterhole_WA"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())
```

The station name and id are constant across the year’s temperature and precipitation data. For that reason, we can reorganize these data into a new data frame with a single row for each station. Weather data will be separated into three station-specific data frames, each of which is the data “observation” for the respective station. 

Here, we nest within station. 

```{r}
weather_nest = 
  nest(weather, data = date:tmin)

weather_nest
```

Here I’ve used nest by specifying a column range to collapse within remaining variable values.

The name column is a character column – if you pull this column from the weather data frame, the result is a character vector. Similarly, the data column is a list column – on it’s own, it’s a list.

```{r}
weather_nest %>% pull(name)
weather_nest %>% pull(data)
```

The list column really is a list, and will behave as such elsewhere in R. So, for example, you can examine the first list entry using usual list index procedures.

```{r}
weather_nest$data[[1]]
```

Of course, if you can nest data you should be able to unnest it as well, and you can (with the caveat that you’re unnesting a list column that contains a data frame).

```{r}
unnest(weather_nest, cols = data)
```

Nesting columns can help with data organization and comprehension by masking complexity you’re less concerned about right now and clarifying the things you are concerned about. In the weather data, it can be helpful to think of stations as the basic unit of observation, and daily weather recordings as a more granular level of observation. Nesting can also simplify the use of analytic approaches across levels of a higher variable.

## Operations on listcols

Let's say that, within each weather station, we want to see weather tmax is associated with tmin. You could do something like: 

```{r}
central_park_df = weather_nest$data[[1]]

lm(tmax ~ tmin, data = central_park_df)

lm(tmax ~ tmin, data = weather_nest$data[[1]])
lm(tmax ~ tmin, data = weather_nest$data[[2]])
lm(tmax ~ tmin, data = weather_nest$data[[3]])

```

We could try a loop: 

```{r}
output = vector("list", length = 3)

for (i in 1:3) {
  
  output[[i]] = lm(tmax ~ tmin, weather_nest$data[[i]])
}
```

Now the map. First we define the function, then the map. 

```{r}
weather_lm = function(df) {
  
  lm(tmax ~ tmin, data = df)
  
}
```

```{r}
for (i in 1:3) {
  
  output[[i]] = weather_lm(weather_nest$data[[i]])
  
}

output = map(weather_nest$data, weather_lm)
```


The map function returns a list; we could store the results as a new list column … !!!

We’ve been using mutate to define a new variable in a data frame, especially one that is a function of an existing variable. That’s exactly what we will keep doing.

```{r}
weather_nest = 
  weather_nest %>% 
  mutate(models = map(data, weather_lm))

weather_nest
```

This is great! We now have a data frame that has rows for each station; columns contain weather datasets and fitted models. This makes it very easy to keep track of models across stations, and to perform additional analyses.

This is, for sure, a fairly complex bit of code, but in just a few lines we’re able to fit separate linear models to each of our stations. And, once you get used to list columns, map, and the rest of it, these lines of code are pretty clear and can be extended to larger datasets with more complex structures.


 